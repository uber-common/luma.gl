/* eslint-disable camelcase */
import {createGLContext} from '@luma.gl/webgl';
import {assembleShaders, picking, fp64} from '@luma.gl/shadertools';
import test from 'tape-catch';

const fixture = {
  gl: createGLContext()
};

const VS_GLSL_300 = `\
#version 300 es

in vec4 positions;

void main(void) {
  gl_Position = positions;
}
`;
const FS_GLSL_300 = `\
#version 300 es

precision highp float;

out vec4 fragmentColor;

void main(void) {
  fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);
}
`;

test('assembleShaders#import', t => {
  t.ok(assembleShaders !== undefined, 'assembleShaders import successful');
  t.end();
});

test('assembleShaders#version_directive', t => {
  const assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [picking]
  });
  // Verify version directive remains as first line.
  t.equal(
    assembleResult.vs.indexOf('#version 300 es'),
    0,
    'version directive should be first statement'
  );
  t.equal(
    assembleResult.fs.indexOf('#version 300 es'),
    0,
    'version directive should be first statement'
  );
  t.end();
});

test('assembleShaders#getUniforms', t => {
  // inject spy into the picking module's getUniforms
  // const module = getShaderModule(picking);
  // const getUniformsSpy = makeSpy(module, 'getUniforms');

  let assembleResult;

  // Without shader modules
  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300
  });
  // Verify getUniforms is function
  t.is(typeof assembleResult.getUniforms, 'function', 'getUniforms should be function');

  // With shader modules
  const testModule = {
    name: 'test-module',
    vs: '',
    fs: '',
    getUniforms: (opts, context) => {
      // Check a uniform generated by its dependency
      t.ok(context.picking_uActive, 'module getUniforms is called with correct context');
      return {};
    },
    dependencies: [picking]
  };

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [picking, testModule, fp64]
  });

  // Verify getUniforms is function
  t.is(typeof assembleResult.getUniforms, 'function', 'getUniforms should be function');

  t.end();
});

test('assembleShaders#defines', t => {
  const assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    defines: {IS_TEST: true}
  });

  t.ok(assembleResult.vs.indexOf('#define IS_TEST true') > 0, 'has application defines');
  t.ok(assembleResult.fs.indexOf('#define IS_TEST true') > 0, 'has application defines');

  t.end();
});

test('assembleShaders#shaderhooks', t => {
  const hookFunctions = {
    vs: {
      'vs:LUMAGL_pickColor': {
        signature: 'LUMAGL_pickColor(inout vec4 color)'
      }
    },
    fs: {
      'fs:LUMAGL_fragmentColor': {
        signature: 'LUMAGL_fragmentColor(inout vec4 color)',
        header: 'if (color.a == 0.0) discard;\n',
        footer: 'color.a *= 1.2;\n'
      }
    }
  };

  const moduleInjections = {
    vs: {
      picking: {
        'vs:LUMAGL_pickColor': {
          injection: 'picking_setPickingColor(color.rgb);'
        }
      }
    },
    fs: {
      picking: {
        'fs:LUMAGL_fragmentColor': {
          injection: 'color = picking_filterColor(color);',
          order: Number.POSITIVE_INFINITY
        },
        'fs:#main-end': {
          injection: 'gl_FragColor = picking_filterColor(gl_FragColor);',
          order: Number.POSITIVE_INFINITY
        }
      }
    }
  };

  let assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    hookFunctions,
    moduleInjections
  });
  // Verify version directive remains as first line.
  t.ok(
    assembleResult.vs.indexOf('LUMAGL_pickColor') > -1,
    'hook function injected into vertex shader'
  );
  t.ok(
    assembleResult.fs.indexOf('LUMAGL_fragmentColor') > -1,
    'hook function injected into fragment shader'
  );
  t.ok(
    assembleResult.fs.indexOf('if (color.a == 0.0) discard;') > -1,
    'hook header injected into fragment shader'
  );
  t.ok(
    assembleResult.vs.indexOf('picking_setPickingColor(color.rgb)') === -1,
    'injection code not included in vertex shader without module'
  );
  t.ok(
    assembleResult.fs.indexOf('color = picking_filterColor(color)') === -1,
    'injection code not included in fragment shader without module'
  );

  t.ok(
    assembleResult.fs.indexOf('gl_FragColor = picking_filterColor(gl_FragColor)') === -1,
    'regex injection code not included in fragment shader without module'
  );

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [picking],
    hookFunctions,
    moduleInjections
  });
  // Verify version directive remains as first line.
  t.ok(
    assembleResult.vs.indexOf('LUMAGL_pickColor') > -1,
    'hook function injected into vertex shader'
  );
  t.ok(
    assembleResult.fs.indexOf('LUMAGL_fragmentColor') > -1,
    'hook function injected into fragment shader'
  );
  t.ok(
    assembleResult.vs.indexOf('picking_setPickingColor(color.rgb)') > -1,
    'injection code included in vertex shader with module'
  );
  t.ok(
    assembleResult.fs.indexOf('color = picking_filterColor(color)') > -1,
    'injection code included in fragment shader with module'
  );
  t.ok(
    assembleResult.fs.indexOf('color.a *= 1.2;') >
      assembleResult.fs.indexOf('color = picking_filterColor(color)'),
    'hook footer injected after injection code'
  );
  t.ok(
    assembleResult.fs.indexOf('gl_FragColor = picking_filterColor(gl_FragColor)') > -1,
    'regex injection code included in fragment shader with module'
  );

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    inject: {
      'vs:LUMAGL_pickColor': 'color *= 0.1;',
      'fs:LUMAGL_fragmentColor': 'color += 0.1;'
    },
    hookFunctions,
    moduleInjections
  });

  t.ok(
    assembleResult.vs.indexOf('color *= 0.1') > -1,
    'argument injection code included in shader hook'
  );
  t.ok(
    assembleResult.fs.indexOf('color += 0.1') > -1,
    'argument injection code included in shader hook'
  );

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    inject: {
      'fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);': 'fragmentColor -= 0.1;'
    },
    hookFunctions,
    moduleInjections
  });

  t.ok(
    assembleResult.fs.indexOf('fragmentColor -= 0.1;') > -1,
    'regex injection code included in shader hook'
  );

  t.end();
});
